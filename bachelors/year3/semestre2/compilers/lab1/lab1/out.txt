COMMENT {*****************************************************************************
 * A Pascal quicksort.
 *****************************************************************************}
RESERVED program
IDENTIFIER sort
OPERATOR (
IDENTIFIER input
OPERATOR ,
IDENTIFIER output
OPERATOR )
OPERATOR ;
RESERVED const
COMMENT { Max array size. }
IDENTIFIER maxelts
OPERATOR =
CONSTANT 50
OPERATOR ;
RESERVED type
COMMENT { Type of the element array. }
IDENTIFIER intarrtype
OPERATOR =
RESERVED array
OPERATOR [
CONSTANT 1.
OPERATOR .
IDENTIFIER maxelts
OPERATOR ]
RESERVED of
IDENTIFIER integer
OPERATOR ;
RESERVED var
COMMENT { Indexes, exchange temp, array size. }
IDENTIFIER i
OPERATOR ,
IDENTIFIER j
OPERATOR ,
IDENTIFIER tmp
OPERATOR ,
IDENTIFIER size
OPERATOR :
IDENTIFIER integer
OPERATOR ;
COMMENT { Array of ints }
IDENTIFIER arr
OPERATOR :
IDENTIFIER intarrtype
OPERATOR ;
COMMENT { Read in the integers. }
RESERVED procedure
IDENTIFIER readarr
OPERATOR (
RESERVED var
IDENTIFIER size
OPERATOR :
IDENTIFIER integer
OPERATOR ;
RESERVED var
IDENTIFIER a
OPERATOR :
IDENTIFIER intarrtype
OPERATOR )
OPERATOR ;
RESERVED begin
IDENTIFIER size
OPERATOR :=
CONSTANT 1
OPERATOR ;
RESERVED while
RESERVED not
IDENTIFIER eof
RESERVED do
RESERVED begin
IDENTIFIER readln
OPERATOR (
IDENTIFIER a
OPERATOR [
IDENTIFIER size
OPERATOR ]
OPERATOR )
OPERATOR ;
RESERVED if
RESERVED not
IDENTIFIER eof
RESERVED then
IDENTIFIER size
OPERATOR :=
IDENTIFIER size
OPERATOR +
CONSTANT 1
RESERVED end
RESERVED end
OPERATOR ;
COMMENT { Use quicksort to sort the array of integers. }
RESERVED procedure
IDENTIFIER quicksort
OPERATOR (
IDENTIFIER size
OPERATOR :
IDENTIFIER integer
OPERATOR ;
RESERVED var
IDENTIFIER arr
OPERATOR :
IDENTIFIER intarrtype
OPERATOR )
OPERATOR ;
COMMENT { This does the actual work of the quicksort.  It takes the
          parameters which define the range of the array to work on,
          and references the array as a global. }
RESERVED procedure
IDENTIFIER quicksortrecur
OPERATOR (
IDENTIFIER start
OPERATOR ,
IDENTIFIER stop
OPERATOR :
IDENTIFIER integer
OPERATOR )
OPERATOR ;
RESERVED var
IDENTIFIER m
OPERATOR :
IDENTIFIER integer
OPERATOR ;
COMMENT { The location separating the high and low parts. }
IDENTIFIER splitpt
OPERATOR :
IDENTIFIER integer
OPERATOR ;
COMMENT { The quicksort split algorithm.  Takes the range, and
              returns the split point. }
RESERVED function
IDENTIFIER split
OPERATOR (
IDENTIFIER start
OPERATOR ,
IDENTIFIER stop
OPERATOR :
IDENTIFIER integer
OPERATOR )
OPERATOR :
IDENTIFIER integer
OPERATOR ;
RESERVED var
IDENTIFIER left
OPERATOR ,
IDENTIFIER right
OPERATOR :
IDENTIFIER integer
OPERATOR ;
COMMENT { Scan pointers. }
IDENTIFIER pivot
OPERATOR :
IDENTIFIER integer
OPERATOR ;
COMMENT { Pivot value. }
COMMENT { Interchange the parameters. }
RESERVED procedure
IDENTIFIER swap
OPERATOR (
RESERVED var
IDENTIFIER a
OPERATOR ,
IDENTIFIER b
OPERATOR :
IDENTIFIER integer
OPERATOR )
OPERATOR ;
RESERVED var
IDENTIFIER t
OPERATOR :
IDENTIFIER integer
OPERATOR ;
RESERVED begin
IDENTIFIER t
OPERATOR :=
IDENTIFIER a
OPERATOR ;
IDENTIFIER a
OPERATOR :=
IDENTIFIER b
OPERATOR ;
IDENTIFIER b
OPERATOR :=
IDENTIFIER t
RESERVED end
OPERATOR ;
RESERVED begin
COMMENT { Split }
COMMENT { Set up the pointers for the hight and low sections, and
                      get the pivot value. }
IDENTIFIER pivot
OPERATOR :=
IDENTIFIER arr
OPERATOR [
IDENTIFIER start
OPERATOR ]
OPERATOR ;
IDENTIFIER left
OPERATOR :=
IDENTIFIER start
OPERATOR +
CONSTANT 1
OPERATOR ;
IDENTIFIER right
OPERATOR :=
IDENTIFIER stop
OPERATOR ;
COMMENT { Look for pairs out of place and swap 'em. }
RESERVED while
IDENTIFIER left
OPERATOR <=
IDENTIFIER right
RESERVED do
RESERVED begin
RESERVED while
OPERATOR (
IDENTIFIER left
OPERATOR <=
IDENTIFIER stop
OPERATOR )
RESERVED and
OPERATOR (
IDENTIFIER arr
OPERATOR [
IDENTIFIER left
OPERATOR ]
OPERATOR <
IDENTIFIER pivot
OPERATOR )
RESERVED do
IDENTIFIER left
OPERATOR :=
IDENTIFIER left
OPERATOR +
CONSTANT 1
OPERATOR ;
RESERVED while
OPERATOR (
IDENTIFIER right
OPERATOR >
IDENTIFIER start
OPERATOR )
RESERVED and
OPERATOR (
IDENTIFIER arr
OPERATOR [
IDENTIFIER right
OPERATOR ]
OPERATOR >=
IDENTIFIER pivot
OPERATOR )
RESERVED do
IDENTIFIER right
OPERATOR :=
IDENTIFIER right
OPERATOR -
CONSTANT 1
OPERATOR ;
RESERVED if
IDENTIFIER left
OPERATOR <
IDENTIFIER right
RESERVED then
IDENTIFIER swap
OPERATOR (
IDENTIFIER arr
OPERATOR [
IDENTIFIER left
OPERATOR ]
OPERATOR ,
IDENTIFIER arr
OPERATOR [
IDENTIFIER right
OPERATOR ]
OPERATOR )
OPERATOR ;
RESERVED end
OPERATOR ;
COMMENT { Put the pivot between the halves. }
IDENTIFIER swap
OPERATOR (
IDENTIFIER arr
OPERATOR [
IDENTIFIER start
OPERATOR ]
OPERATOR ,
IDENTIFIER arr
OPERATOR [
IDENTIFIER right
OPERATOR ]
OPERATOR )
OPERATOR ;
COMMENT { This is how you return function values in pascal.
                      Yeccch. }
IDENTIFIER split
OPERATOR :=
IDENTIFIER right
RESERVED end
OPERATOR ;
RESERVED begin
COMMENT { QuicksortRecur }
COMMENT { If there's anything to do... }
RESERVED if
IDENTIFIER start
OPERATOR <
IDENTIFIER stop
RESERVED then
RESERVED begin
IDENTIFIER splitpt
OPERATOR :=
IDENTIFIER split
OPERATOR (
IDENTIFIER start
OPERATOR ,
IDENTIFIER stop
OPERATOR )
OPERATOR ;
IDENTIFIER quicksortrecur
OPERATOR (
IDENTIFIER start
OPERATOR ,
IDENTIFIER splitpt
OPERATOR -
CONSTANT 1
OPERATOR )
OPERATOR ;
IDENTIFIER quicksortrecur
OPERATOR (
IDENTIFIER splitpt
OPERATOR +
CONSTANT 1
OPERATOR ,
IDENTIFIER stop
OPERATOR )
OPERATOR ;
RESERVED end
RESERVED end
OPERATOR ;
RESERVED begin
COMMENT { Quicksort }
IDENTIFIER quicksortrecur
OPERATOR (
CONSTANT 1
OPERATOR ,
IDENTIFIER size
OPERATOR )
RESERVED end
OPERATOR ;
RESERVED begin
COMMENT { Read }
IDENTIFIER readarr
OPERATOR (
IDENTIFIER size
OPERATOR ,
IDENTIFIER arr
OPERATOR )
OPERATOR ;
COMMENT { Sort the contents. }
IDENTIFIER quicksort
OPERATOR (
IDENTIFIER size
OPERATOR ,
IDENTIFIER arr
OPERATOR )
OPERATOR ;
COMMENT { Print. }
RESERVED for
IDENTIFIER i
OPERATOR :=
CONSTANT 1
RESERVED to
IDENTIFIER size
RESERVED do
IDENTIFIER writeln
OPERATOR (
IDENTIFIER arr
OPERATOR [
IDENTIFIER i
OPERATOR ]
OPERATOR )
RESERVED end
OPERATOR .
